# Data Modeling Case Studies – E-Commerce & Hospital (Mongoose Notes)

## Core Principles

### 1. Start With Entities

Ask:

> What data exists in the system?

Then define:

* Fields
* Relationships
* Constraints

---

## Naming Best Practices

* Model name → **Singular**
* First letter → **Capital**

```
User
Product
Order
Hospital
```

MongoDB automatically creates plural collections.

---

# E-Commerce Data Modeling

---

## 1. User Model

### Fields

* username (unique)
* email (unique)
* password

### Example

```js
const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true, trim: true },

  email: { type: String, required: true, unique: true, lowercase: true },

  password: { type: String, required: true, minlength: 6 }
}, { timestamps: true });
```

---

## 2. Category Model

Simple structure.

```js
const categorySchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true,
    trim: true
  }
});
```

---

## 3. Product Model

### Fields

* name
* description
* price
* stock
* images (URLs)
* category (ref)
* owner (User ref)

### Why URLs?

Store images in:

* Cloudinary / S3
  Store only:

```
image: "https://..."
```

### Example

```js
const productSchema = new mongoose.Schema({
  name: { type: String, required: true },
  description: String,
  price: { type: Number, required: true },
  stock: { type: Number, default: 0 },
  images: [String],

  category: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Category"
  },

  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User"
  }
}, { timestamps: true });
```

---

## 4. Order Model

Complex structure with nested items.

### OrderItem Schema

```js
const orderItemSchema = new mongoose.Schema({
  productId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Product",
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: 1
  }
});
```

---

### Order Schema

Fields:

* orderPrice
* customer (User ref)
* orderItems (array)
* orderStatus (enum)

```js
const orderSchema = new mongoose.Schema({
  orderPrice: {
    type: Number,
    required: true
  },
  customer: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true
  },
  orderItems: [orderItemSchema],
  orderStatus: {
    type: String,
    enum: ["PENDING", "COMPLETED", "CANCELLED"],
    default: "PENDING"
  }
}, { timestamps: true });
```

---

## Relationships (E-Commerce)

| Model                | Relationship |
| -------------------- | ------------ |
| User → Order         | One to Many  |
| Category → Product   | One to Many  |
| Product → OrderItems | One to Many  |

---

# Hospital Management Data Modeling

---

## 1. Hospital Model

### Fields

* name
* address (nested)
* specializedIn (array)

```js
const hospitalSchema = new mongoose.Schema({
  name: { type: String, required: true },
  address: {
    addressLine1: String,
    addressLine2: String,
    city: String,
    pincode: String
  },
  specializedIn: [String]
});
```

---

## 2. Doctor Model

Doctors can work in **multiple hospitals**.

Fields:

* name
* salary
* qualifications
* experienceInYears
* worksInHospital (array ref)

```js
const doctorSchema = new mongoose.Schema({
  name: { type: String, required: true },
  salary: Number,
  qualifications: [String],
  experienceInYears: Number,
  worksInHospital: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: "Hospital"
  }]
});
```

---

## 3. Patient Model

Fields:

* name
* diagnosis
* address
* age
* bloodGroup
* gender (enum)
* admittedIn (Hospital ref)

```js
const patientSchema = new mongoose.Schema({
  name: { type: String, required: true },
  diagnosis: String,
  address: String,
  age: Number,
  bloodGroup: String,
  gender: {
    type: String,
    enum: ["MALE", "FEMALE", "OTHER"]
  },
  admittedIn: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Hospital"
  }
});
```

---

## Relationships (Hospital)

| Model              | Relationship |
| ------------------ | ------------ |
| Hospital → Doctor  | Many to Many |
| Hospital → Patient | One to Many  |
| Doctor → Hospital  | Many to Many |

---

# Enums (Important Concept)

Used to restrict values:

```js
status: {
  type: String,
  enum: ["PENDING", "COMPLETED", "CANCELLED"]
}
```

Benefits:

* Data consistency
* Prevent invalid values

---

# General Data Modeling Best Practices

1. Think **entities first**
2. Use references for relationships
3. Use enums for fixed values
4. Store files externally (only URLs)
5. Keep model names:

   * Singular
   * Capitalized
6. Maintain naming consistency
7. Reuse field patterns when possible

---

# Goal of This Module

Build confidence to:

* Design schemas for any application
* Identify relationships correctly
* Structure scalable MongoDB models
* Think like a backend architect
